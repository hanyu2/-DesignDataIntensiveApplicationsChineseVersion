# 第一部分

# 数据系统基础

前四章将会浏览一遍应用在所有数据系统上的基本思想，不论是单节点还是分布式机器：

1. 第一章介绍贯穿本书中使用的术语和方法。我们将会认真定义我们使用的一些用辞，比如可靠性，可扩展性，可维护性，我们也会探讨我们是如何尝试完成这些目标的。
2. 在第二章，我们将会比较几种不通的数据模型和查询语言——这是程序员眼中不同数据库之间最大的差异。我们也会了解各种模型是如何适应不同的场景的
3. 在第三章我们会回到存储引擎的内部来看一下数据库如何在磁盘上组织数据。不通的存储引擎针对不同的工作量有各自的优化，选择正确的优化策略会对性能有着极大的影响。
4. 在第四章我们会对比不同的数据编码（序列化）格式，尤其会着重关注在应用的需求改变和schema随着时间演变的过程中编码格式是如何表现的。

此后在第二部分我们会转向讨论分布式数据系统的具体问题。

![](https://vonng.gitbooks.io/ddia-cn/content/img/ch1.png)

# 第一章

# 可靠的，可扩展的，可维护的应用

> 互联网做得如此出色以至于很多人觉得他们像太平洋一样的自然资源，而不是像是一个人工产物。上一次出现如此大规模且无差错的技术是什么时候？
>
> ——阿兰·凯在接受Dobb博士杂志采访时说（2012年）

当代的很多应用都是数据密集型的，而不是计算密集型。CPU的算力已经不是这些应用的限制因素，更大的问题是数据的量级，数据的复杂度和数据的演变速度。

一个数据密集型的应用一般来说是由服务常用功能的标准模块集成起来的。比如，很多应用需要：

- 存储数据以供自己或者其他以应用读取（数据库）
- 缓存复杂运算的结果来加速读取（缓存）
- 允许用户通过关键词或者各种过滤搜索（搜索索引）
- 发送消息给其他进程去实现异步处理（流处理）
- 定期处理积累的大批量数据（批处理）

如果那听起来过于太平平无奇，是因为数据系统抽象的太完美：我们总在用他们却缺乏思考。在开发一个应用时，大部分的工程师并不会幻想从0写一个新的数据数据存储引擎，因为数据可时做这件事的完美工具。

但事实并非如此简单。很多数据库有不同的特性，因为不同的应用有不同的要求。有很多不同的方法做缓存，搜索索引等等。在开发一个应用时，我们任然需要找出哪一种工具，哪一种方法是最适合我们手头的任务需求。当一件供给无法独立完成一项需求的时候，综合使用多种工具同样可能会很有难度。

这本书是一本穿越数据系统的原理，实践的旅程，也会讲解我们是如何用他们开发数据密集的应用。我们会探索不同工具的共同点，各自的特点和他们是如何实现的自己的特性的。

在这一章，我们会通过探索我我们基础目标：可靠性，扩展性，可维护性的数据系统开始。我们会弄清这些词是什么意思，概括思考他们的方法，并了解后续章节的一些基本知识。在后续章节中我们会继续分层查看各种数据密集型应用的开发中需要考虑的各种不同设计决策。

## 关于数据系统的思考

我们习惯性的以为数据库，队列，缓存等等是非常不同的工具类别。尽管数据库和消息队列有着非常明显的共性——他们都会把数据存一段时间——但是他们有着非常不同的读取模式，那就意味着有不同的性能特性，也会有非常不同的实现方法。

所以我们为什么把他们混在数据系统这个大伞之下呢？

近些年有很多新生的数据存储和处理的工具。他们针对各种不同的使用场景做了优化，他们也不完美地归纳到传统类别。比如，数据存储也被用作消息队列（Redis）,同样也有消息队列有着数据库特性的持久性保证（Apache Kafka）。这些类别之间的界限正在面的越来越模糊。

第二，有越来越多的应用现在有着单一工具对其数据处理和数据存储无法满足的强烈广泛的需求。取而代之的是这些工作被拆解成了单一工具可以高效工作的任务，这些不同的工具不应用程序的代码串联起来。

比如，如果你有一个应用层面馆里的缓存层（使用Memcached或类似的），或者一个有一个和主数据库分离的全文检索服务器（例如Elasticsearch或者Solar），很自然的是应用程序的代码需要负责缓存和索引系统与主数据库的同步。图1-1给出了这个系统的大致轮廓（我们会在后续章节深入探究）。

![](https://vonng.gitbooks.io/ddia-cn/content/img/fig1-1.png)

*图1-1 一个集成多各组件的数据系统的可能架构*

当你为了服务用户来集成一些工具是，服务的接口或者服务的API的实现通常是对于客户端是不可见的。现在你已经使用较小的，有通用功能的组件开发了一个新的，有特定目的的数据系统。你的复合的数据系统可能能提供一些保证：比如，缓存可以在写入的时候可以正确地作废或者更新以保证客户端可以看到一致的结果。你现在不仅只是一个应用的开发者，也是一个数据系统的设计者。

如果你正在设计一个数据系统或者服务，会遇到很多棘手的问题。党内部系统出错时，你如何保证数据的正确性和完整性？当部分系统降级服务，如何保证对客户端稳定的高性能服务？负载增加时如何扩容？一个好的服务API应该是什么样的。

有你多因素影响着你的数据系统的设计，包括参与人员的技术和经验，历史遗留系统的依赖，交付时间，你的公司对不同风险的承受能力，和法规限制，这些因素都要具体情况具体分析。

在这本书里，我们关注在一下三个对大多数软件系统都至关重要的方面：

*可靠性*

系统应该持续正常工作（功能在期望的性能下运行）即便遇到问题（硬件或者软件缺陷，甚至是人为错误）。

*可扩展性*

当系统在增长时（数据量，流量，或者复杂度），应该有合理的办法应对这种增长

*可维护性*

在一段时间内，很多不同的人在一个系统上开发（工程师，运维都会维护当前系统的正常运行并适应新的应用场景），他们都应该能高效地在这个系统中工作。

人们经常会去努力完成以上的目标却没有一个准确清晰的定义。为了做到有思想的工程，我们会在本章剩余的内容中探索可靠性，可扩展性，可维护性的思考方式。然后在此后的章节里我们会探寻为了达成这些目标的各种技巧，架构和算法。

## 可靠性

每个人都有对于可靠或者不可靠的理解。对于软件来说，通常的期望包括：

- 应用的运行符合用户期望
- 对于用户的使用错误或者非常规的使用方法有容错能力
- 在预期的负载和数据量下对于要求的使用场景下性能表现依然良好
- 系统可以组织任何未经授权的访问和滥用

如果所有的这些放在一起代表着“工作正常”，那么我们粗略地把*可靠性*理解为“即使出现问题也能正常工作”

出错的地方我们叫做*故障*，能够遇见故障并能解决他们的被称作*容错的*或者是*有韧性*的系统。前一个词可能会有误导：它意味着我们可以开发一个能容纳各种可能故障的系统，现实里其实是不可能做到的。如果整个地球（包括地球上的所有服务器）都被一个黑洞吞噬，如果需要包容这种错误需要把web服务器放在太空，如果申请这种预算那只能祝你好运了。所以讨论特定类型的容错才有意义。

注意故障不等同于失效。故障通常被定义为系统中的一个组件偏离其标准，但是*失效*是整个系统停止了对用户承诺的服务。我们无法把故障率降低到0，因此设计容错机制通常最好的设计是防止故障导致的失效。本书中我们会介绍几种从不可靠的组件中开发可靠系统的技术。

反直觉的是，在这种容错系统中，有意地触发付账来导致故障率的上升是有意义的，例如在没有警报地情况下随机杀掉一个进程。很多致命的bug是由于差强人意的错误处理导致的；通过有意地引入这些故障能保证容错机制持续运行并接受考验，这样能才能增强处理自然出现的bug被正确处理的信心。Netflix公司的*Chaos Monkey*就是这种方式的例子。

虽然我们通常倾向于容错而不是预防故障，但有些情况预防比处理更高（比如没有处理方法）。有一种情况是关键的安全问题，比如说：如果一个攻击者破坏了系统并拿到了敏感数据的读取权限，这种情况甚至不能撤销。但是这本书主要处理的是能够被处理的故障，就像下面这节描述的一样。

## 硬件故障

当我们思考系统失效原因的时候，硬件故障会迅速闪现在脑海中。硬盘崩溃，RAM错误，电网断电，有人拔错了网线。又在大型数据中心工作经验的人会告诉你如果你有很多机器这些情况经常发生。



