# 第二章

## 数据模型和查询语言

> 语言的边界就是思想的边界。
>
> —— 路德维奇·维特根斯坦，《逻辑哲学》（1922）

数据模型有可能是再开发软件时最重要的部分了，因为它有着非常深远的影响：不仅是软件是如何编写的，也是我们思考我们待解决的问题的方式。

很多应用是建立在一层又一层的数据模型之上。对于每一层关键的问题是：他是如何*代表*着下一层的数据？比如：

1. 作为应用开发者，你观察了真实世界（这里面有人，组织，货品，行为，货币流动，传感器等），并用对象或者数据结构，还有操控数据结构的API来建模。这些结构通常是针对特定应用。
2. 当你想存储这些数据结构，你用一种通用的数据模型来展现他们，比如JASON或者XML文档，关系型数据库的表，或者图模型。
3. 开发你的数据库软件的工程师用某种方式在内存，磁盘，或者网络中以字节的形式代表了JSON/XML/关系型/图数据。这种表现形式可能让我们来以各种方法来查询，搜索，操作或者处理数据。
4. 在更底层，硬件工程师已经知道如何用电流，光脉冲，磁场或者其他东西来表示字节的方法。

一个复杂的应用可能会有更多的中间层，比如在API上开发的API，但是基本的思想仍然不变：每层通过提供一个清晰的数据模型隐藏了下一层的复杂度。这些抽象帮助不同角色的人——比如提供数据库和使用他们数据库的工程师——更高效地工作。

有很多不同的数据模型，每一种数据模型包含了数据使用方法的假设。有一些用法是非常简单的，有一些用法是不支持的，有一些操作很快，有一些可能很慢，有一些转换很自然而有一些很拙劣。

精通一中数据结构会耗费很多精力（试想有多找关系型数据库建模的书）。即使不考虑一种数据模型的内在工作原理的情况下，开发软件也足够难了。但是由于数据模型影响如此深远，决定了开发出来软件什么能做，什么不能做，所以在选择软件适用的模型上非常重要。

在本章我们会看各种数据存储和查询（前面列表中的第2点）通用的数据模型。尤其是我们会比较各种关系模型，文档模型，和几个图数据模型。我们也会了解各种查询语言并比较他们的使用场景。在第三章。我们会讨论存储引擎的工作原理，也就是数据模型实际上是如何实现的（前面列表中的第2点）。

## 关系模型VS文档模型

现在最有名的数据模型可能是SQL，基于Edgar Codd 在1970年提出的关系型模型上：数据被组织在关系（SQL里叫表）里，每种关系都是一个无序元组的集合（SQL里的行）。

关系模型是一种理论模型，同时代有很多人质疑他的实现效率。但是在二十世纪中，对于有常规结构的数据存储和查询需要的大部分开发人员，关系型数据库管理系统（RDBMSes）和SQL已经成为了首选。关系型数据库已经主导了25到30年——这在计算历史上已经是非常漫长的了。

关系型数据库起源于*商业数据处理*，在二十世纪六七十年代用大型计算机来执行。用今天的视角来看，这种例子显得平平无奇：典型的*事务处理*（输入销售或者银行交易，航空预定，库存系统记录）和批处理（客户发票，工资单，报告）。

在那个年代的其他数据库强迫应用开发人员去考虑很多在数据库内部的数据展现形式。关系型模型的目标是在一个简洁的接口背后隐藏实现的具体细节。

在过去的这些年里，在数据存储和查询方面有很多竞争的方法。在70年代和80年代初，*网络模型*和封层模型曾经是主要的选择，但是关系型模型后来开始主宰。对象数据库在二十世纪80年代末90年代初曾经来了又走。XML数据库在二十一世纪早期出现，但是只有小众采用过。每个关系型模型的每个竞争者在那个时代都有大肆炒作，但是从来没有长久过。

当计算机变得更性能更强劲，变得更加互联，他们开始用在了越来越多的目的。在原来的业务数据处理之外，关系型数据库用途也越来越广泛，今天你在网络上看到的很多东西也是有关系型数据库的支持，比如在线发布，社交，电商，游戏，SaaS程序应用等更多用途。

## NoSQL的诞生

现在在2010年代，NoSQL是挑战关系型模型的最新尝试。“NoSQL”这个名字有点不太幸运，他并没有代指哪一种技术，而是一次开源，分布式，非关系型数据库的Meetup在Twitter上醒目的标签，尽管如此，这个词还是触动了人们的神经，并迅速在互联网创业圈以及更大的范围迅速传播。有很多有意思的数据库系统现在贴上了#NoSQL的标签，并被重新解释为“不仅是SQL（Not Only SQL）”。

采用NoSQL数据库有几个驱动因素：

- 比关系型数据库可以实现更大的可扩展性，包括极大地数据集或者极高的吞吐量。
- 倾向使用各种各样免费，开源软件而不是商业数据库产品
- 关系型模型不能支持的一些特殊查询操作
- 关系型schema的限制让你很受挫，需要一种更动态的和更有传达力的表现模型

不同的应用有着不同的要求，一种使用场景的选择的最优技术可能对另一种使用场景并不是一个最好的选择。因此看起来是有在可预见的未来，关系型数据库会一直与各种非关系型数据库一起使用——这种想法有时也被称为混合持久化（polyglot persistence）。

## 对象关系型的不匹配

今天很多应用的开发都是用面向对象语言完成的，导致了对SQL数据类型的普遍批评：如果数据在关系型表中存储，在应用程序代码和数据库表，行，列的模型会有一个很尴尬的转换层。这种模型之间的断层有时被称为阻抗不匹配（impedance mismatch）。

> 阻抗不匹配是从电子学借来的术语。每个电路的输入和输出都有一定的阻抗（交流电阻），当你将一个电路的输出连接到另一个电路的输入时，如果两个电路的输出和输入阻抗匹配，则连接上的功率传输将被最大化。阻抗不匹配会导致信号反射及其他问题。

类似ActiveRecord和Hibernate的对象-关系映射框架减少了转换层所需的模板代码的数量，但是他们完全不能隐藏两个模型之间的差异。

比如，在图2-1展示了在关系型schema里是如何展示一份简历的。这个简历整体可以被一个标识符（user_id）来确定。像姓，名这样的字段在每个用户里只出现一次，所以他们能被当成user表里当成列来建模。但是，大多数人在他们的职业生涯里有不仅一份工作，人们也有不同时长的教育背景，有很多联系方式。同样也有一对多（从一个人到这些信息）的关系，这些关系有以下的表现方式：

- 在传统的SQL模型（在SQL1999之前），最常见的范式表现方式是把职位，教育，联系信息放在不同的表里，用一个外键指向user表，像图2-1展示的那样。
- 后面SQL标准的版本添加了对结构化数据和XML数据类型的支持，这样支持了单行对多值数据的支持，这样支持了在这些文档中查询和索引的支持。Oracle在不同程度上支持了这些功能，IBM DB2, MS SQL Server，和ProfreSQL。很多数据库支持了JSON的数据类型，包括IBM DB2, MS SQL Server，和ProfreSQL。
- 一个第三选择是把工作，教育和联系信息编码成JSON或者XML文档的格式，当做一个文本存在数据库里，让应用去来根据结构和内容去做解析。在这种配置下，我们通常不能用数据库来查询被编码后的列的内容。

![](https://vonng.gitbooks.io/ddia-cn/content/img/fig2-1.png)

*图2-1 LinkedIn个人资料用关系型schema的展现。*

像简历这样的数据结构，大部分都是自包含的文档，一个JSON的表现形式是非常合适的。参考2-1这个例子，JSON比XML更简单。面向文档的数据库例如MongoDB，RethinkDB，CouchDB和Epressod都支持这种数据模型。

*例子2-1 LinkedIn个人简介的JSON文档的表示*

```json
{
  "user_id": 251,
  "first_name": "Bill",
  "last_name": "Gates",
  "summary": "Co-chair of the Bill & Melinda Gates... Active blogger.",
  "region_id": "us:91",
  "industry_id": 131,
  "photo_url": "/p/7/000/253/05b/308dd6e.jpg",
  "positions": [
    {
      "job_title": "Co-chair",
      "organization": "Bill & Melinda Gates Foundation"
    },
    {
      "job_title": "Co-founder, Chairman",
      "organization": "Microsoft"
    }
  ],
  "education": [
    {
      "school_name": "Harvard University",
      "start": 1973,
      "end": 1975
    },
    {
      "school_name": "Lakeside School, Seattle",
      "start": null,
      "end": null
    }
  ],
  "contact_info": {
    "blog": "http://thegatesnotes.com",
    "twitter": "http://twitter.com/BillGates"
  }
}
```

一些开发者觉得JSON模型减少了应用代码和存储层之间的阻抗不匹配。但是，在第四章章我们也会看到，把JSON作为编码格式也有很多。无schema经常被认为是一个优势，我们会在“文档模型中的schema灵活性”中讨论这个问题。

JSON的表示形式比图2-1中的多表schema有者更好地局部性。如果你想在关系型例子取一个个人资料，你需要执行多个查询（用user_id查询多个表）或者在user和其下鼠标之间执行一个混乱的join查询。在这种JASO的表现形式中，所有相关的信息都在一个地方，一个查询就已经足够了。

从用户表到用户职位，教育背景，联系方式的一对多的关系按时了数据中的一种树模型，JSON的展示让这种模型显得更加明了（图2-2）。

![](https://vonng.gitbooks.io/ddia-cn/content/img/fig2-2.png)

*图2-2 一对多关系构建的树结构*

## 一对多和多对多关系

在前一节的2-1例子中，region_id和industry_id都是以id形式给出的，而不是纯文本字符串“Great Seattle Area”和“Philanthropy”，为什么？

如果用户节面在输入地区和行业的时候可以自由输入文本，那把他们存成纯文本字符串就是有意义的。但是把地理和行业标准化成为列表，让用户从下拉列表中选择或者自动补全也是有优势的：

- 简介之间的格式和拼写同意
- 避免歧义（比如有一些城市重名）
- 方便更新——明仔只存在一个地方，所以有需要更改的地方方便全局更新（比如由于政治事件导致的城市更名）
- 本地化支持——当一个网站翻译成另外一种语言，标准化列表可以被本地化，所以地区和行业可以以用户的语言展示
- 更好的搜索——例如，搜索华盛顿州的慈善家就可以搜到这个简历，所以地区列表可以在西雅图在华盛顿州的事实编码进去

存储一个id还是文本字符串是一个关于重复的问题。当你用一个id的时候，对人们有意义的信息存在一个地方，任何引用到这写信息的地方都用一个id(只有在这个数据库有意义)。当你直接存储这些文本的时候，你重复了每一条对人类有意义的信息。

用id的好处是id对人类没有意义，从来不需要去更改：即便在id代指的信息改变时，id也可以一直保持不变。对人类有意义的信息在未来可能需要更改——如果信息被复制，所有荣誉的副本都需要被更改。这样导致了写开销和磁盘的不一致（有些信息的副本被更新，有些没有）。移除这些副本是数据库规范化的关键思想。

> 数据库管理员和开发者喜欢争论规范化和非规范化，但是我们在这暂不判断。在本书第三部分中，我们会返回这个主题探索处理缓存，非规范化和衍生数据的系统性方法。

不幸的是，规范化数据需要*多对一*的关系（很多人在某一个地区生活，也有很多人在某一个行业工作），这种不太适合文档模型。在关系型数据库中，通过id找其他表里的一行是很普遍的，因为join是很方便的。在文档数据库中，join对一对多的树结构是不太需要的，对join的支持通常也是不够的。

如果数据库本身不支持这种join，你需要通过在数据库上的多个查询来模拟应用代码里的一个查询。(在这种情况下，地区列表和行业可能是很小的，不常更改的所以应用可以很方便地把他们存储在内存里。然而，join的工作从数据库转移到了应用代码上)。

不仅如此，即使应用的初始版本对不需要join的文档数据库很合适，在应用功能越来越多的情况下，数据有一种更加内联的趋势。比如，让我们考虑一下可以对简历这个例子可能做的修改：

*组织和学校作为实体*

在之前的描述中，组织（用户工作的公司）和学校名字（人们学习的地方）都只是字符串。或许我们应该有对这些实体的引用？然后每个组织，学校或者大学可以有他们自己的网页（有标志，新闻等）；每个简历可以链接到连到的组织和学校，包括他们的标志和其他信息（用图2-3里LinkedIn的例子）。

*推荐语*

如果你想增加一个新功能：一个用户可以为另一个用户写推荐语。推荐语展示在被推荐的用户的简历上，同样也有推荐人的名字和照片。如果推荐人更新了他们的照片，任何他们写了推荐语的地方都会显示新的照片。因此，推荐语应该有一个推荐人的引用。

![](https://vonng.gitbooks.io/ddia-cn/content/img/fig2-3.png)

*图2-3公司名字不仅是一个字符串，更是一个对公司实体的链接。这是LinkedIn的截图。*

图2-4展示了这些新功能是如何需要这种一对一的关系。每个虚线矩形内的的数据可以聚合到一个文档内，但是对其他组织，学校和其他用户的引用需要以引用来展现，查询时需要join。

![](https://vonng.gitbooks.io/ddia-cn/content/img/fig2-4.png)

*图2-4 用多对多的关系扩展简历*

## 文档数据库是否在重蹈覆辙？

多对多的关系和join经常是用在关系型数据库时，文档数据库和NoSQL重新打开了关于如何最好在数据库中展示这些关系的讨论。这种讨论比NoSQL早得多——实际上这可以追溯到计算机化数据系统的最早期。

二十世纪七十年代最受欢迎的商业数据处理的数据库是IBM的信息管理系统（IMS），这个原本是为了阿波罗空间项目的仓库存储管理开发的，并于1968年有了首次商业发布。这个系统现在仍被使用和维护，运行在IBM的OS/390上。

IMS的设计用了一个相当简单的叫做*层次模型*的数据模型，这种模型跟用在文档数据库的JSON模型有这一些惊人的相似之处。他用一个嵌套记录的树结构代表所有数据，更像图2-2中描述的JSON结构

像文档书库一样，IMS对一对多的关系运行非常良好，但是对多对多的关系困难比较大，对join也不支持。开发人员需要去决策究竟是复制（非规范化）数据或者人为的给一套记录建立引用指向另一条记录。这些问题在二十世纪六七十年代是开发人员经常遇到的问题，就像今天人们在用文档数据库遇到的问题一样。

人们提出了各种各样方法来解决层次数据模型的限制。两种流行的解决办法是关系模型（后来变成了SQL，全球流行）和网络模型（一开始有很多拥趸但后来慢慢的淡出视野）。这两大阵营之间的“大辩论”在二十世纪七十年代持续了很久。

因为这两种模型想要解决的问题在今天依然相关，所有必要用今天的视角来简单回顾一下这场辩论。

### 网络模型

网络模型是有一个称为数据系统语言会议（CODASYL）的委员会进行了标准化，由一些数据库厂商实现，也被称为*CODASYL*模型。

这种模型有层次模型泛华出来。在层次模型的树结构中，每一条记录都只有一个父节点；在网络模型中，一条记录可以有多个父节点。比如，可能有一条记录代表“Great Seattle Area”地区，每个生活在这个地区的人可以和那条记录连接起来，这样可以对多对一和多对多的关系进行建模。

网络关系中记录之间的链接不是外键，更像是编程语言中的指针（同样存在磁盘上）。访问一条记录的唯一方法是从一条链接链条中找到根记录。这种被称为*访问路径*；

在这种最简单的例子中，一条访问路径像是遍历一个链表：从表头开始，每次查看一条记录知道你找到你需要的记录。但是在多对多的关系里，很多不同路径可以到达相同的记录，开发人员在网络模型上工作时需要在表链表头记录能到达节点的所有路径。

CODASYL的查询通过在数据库中移动指针来遍历记录链表的指针和跟随访问路径。如果一个记录有多个父节点（比如很多来自其他记录的入指针），这个应用程序的代码需要记录所有各种关系。即使CODASYL委员会的成员也承认这像是在一个n维的数据空间中导航一样。

在七十年代，即便手动选择路径可以在有限的硬件条件（比如磁带驱动器，查找极为缓慢）下最大的发挥性能，但是问题在于查询和更新数据库的代码变得非常复杂不灵活。在层级模型和网络模型中，如果你没有指向你要的数据的路径，你会棉铃这种截然不同的情况。你可以改变访问路径，但是你就需要手写很多数据库查询代码，并需要重写来解决更改新的访问路径的问题。对应用程序的数据模型做这种修改的非常困难的。

### 关系模型

相反的是，关系模型会把所有数据放开：一个关系（表）只是一些元组（行）的集合，仅此而已，没有负载的嵌套结构，也没有负载的查询书库的访问路径。你可以根据各种条件读表里的任意一行数据。你可以通过把一些列指定成键来读到符合条件的任意一行。你可以在不用担心外键连接其他表的情况下在任意一个表里插入新的一行。

> 外键约束允许你对修改约束，但是这种约束不是关系型模型的必选项。即便有约束，在外键上的join是在查询时执行的，但是在CODASYL中是在插入时高效执行的。

在关系型数据库中，查询优化器会自动判断查询中的每一部分的执行顺序，也会判断应该用那个索引。这种选择实际上是*访问路径*，但是最大的不同点在于他是通过查询优化器自动完成的，而不是程序开发人员，所以我们不太需要考虑这些。

如果你想用一种新的方式来查询你的数据，你可以通过声明索引来完成，查询会自动决定哪个索引是最合适的。你不需要更改你的查询来让新的索引起作用。这样关系型才能更加简单地给应用程序增加新功能。

关系型数据库的查询优化器是非常复杂的，已经号位了很多年的研究和开发经理。关系型模型的一个关键洞察是：你只需要开发一次查询优化器，用到这个数据库的所有应用程序都能受惠于此。即便你没有查询优化器，为特定查询手写一访问路径比写一个通用功能的优化器也简单得多——但是通用优化器在长期试用中更有优势。

###和文档数据库比较

在一个方面，文档数据库还是层次模型：存储在父记录中嵌套记录（一对多关系，比如图2-1中的职位，教育背景和联系方式）而不是一个单独的表。

但是，在讨论代表多对一和多对多的关系时，关系和文档数据库有着一些本质上的不同：在这两种情况下，相关的元素都有通过一个独一无二的标识符来引用，这个在关系型模型中被称为*外键*，在文档模型中被称为*文档引用*。这种标识符通过在读取时利用join或者后续查询来实现。迄今为止，文档模型还没有走CODASYL的老路。

## 今天关系型和文档型数据库的对比

当我们比较关系型数据路和文档数据库是有很多不同点需要考虑，把偶偶他们的容错属性（在第五章）和并处理并发能力（第七章）。在这一章我们只关注在两种数据模型的不同点上。

喜爱文档数据模型的主流观点说他们有更灵活的schema，由于局部性有更好的性能，对于一些应用程序，程序和他用到的数据结构更接近。关系型模型通过提供更好的join，多对一还有多对多的支持来反击。

### 哪种数据模型能带来更简单的应用程序代码

如果你的应用程序的数据有着类似文档的结构（日入是一个一对多关系的树，整棵树通常会被一次性载入），那么用文档模型可能会是一个好的选择。关系型模型的*分解*的技术——把一个类似文档的结构分解成许多表（比如图2-1中的职位，教育背景和联系方式）——可能会导致复杂的schema和不必要的应用程序代码。

文档模型有这些限制：比如，你不能在文档中直接引用一个嵌套的项目，所以你得说“用户251的职位列表中的第二项”（更像是分层模型中的访问路径）。但是只要文档模型嵌套不太深，这通常不是个问题。

文档数据库中对join糟糕的支持可能是也可能不是一个问题，这取决于应用程序。比如，多对多的关系可能在一个记录事件发生的文档数据库的分析型应用程序中从来都用不到、

但是，如果你的应用程序的确需要多对多关系，文档模型看起来就没那么吸引人了。我们可以通过反规范化来降低对join的需要，但是应用程序代码反过来需要为了保持被反关系化的数据保持一致增加更多的工作量。join可以在应用程序里通过过给数据库发送多个请求来模拟，但是这也将复杂性转移到应用程序中，通常比数据库里专用的执行join的代码更慢。在这种情况下，用文档模型可能会显著导致更复杂的应用程序代码和更差的性能。

一般情况下不可能那种数据模型能带来更简洁的应用程序代码，这取决于数据之间的关系。对于数据关系特别紧密的情况，文档模型显得捉襟见肘，然而关系模型是更可被接受的，图模型是最自然的。

### 文档模型里Schema的灵活性

关系型数据库里的大多数对文档模型和JSON支持不会对文档中的数据强制任何schema。关系型数据库中对XML的支持有可选的schema验证。无schema意味着接可以插入任意的键和值，在读取时客户端对文档中包含的字段无法保证。

文档数据库有时候被称为是*无schema*的，这个是有误导性的，当应用程序读数据的代码是通常假设是有一些结构的——比如，存在一种隐式schema，但这不是数据库强制的。一个更确切的术语是*读时schema*（数据的结构是隐式的，只有在读取数据时才被解释），与此相反的是*写时schema*（关系型数据库的传统做法，schema是显式的，数据库在写时会保证所有的数据都符合这个schema）。

读时schema类似于编程语言中动态（运行时）数据类型检查，但是写时schema类似于静态（编译时）数据类型检查。像是静态和动态类型检查的相对有点有很大的争议性一样，数据库schema的强制也是一个有争议性的话题，一般来说没有正确或者错误的答案。

在应用程序想找更改数据格式的时候尤其需要注意各种方法之间的不同。比如，你现在吧每个用户的全名存在一个字段中，现在你想吧姓和名分开存储。在文档数据库中，你只需要开始用新字段写一个新文档，然后在应用程序的代码中改一下读旧文档的逻辑，比如：

```java
if (user && user.name && !user.first_name) {
    // Documents written before Dec 8, 2013 don't have first_name            			user.first_name = user.name.split(" ")[0];
}	
```

在另一种方法中，在“静态类型”的数据库schema中，通常会执行以下*迁移*（migration） 操作：

```sql
ALTER TABLE users ADD COLUMN first_name text;
UPDATE users SET first_name = split_part(name, ' ', 1); -- PostgreSQL UPDATE users SET first_name = substring_index(name, ' ', 1); -- MySQL
```

Schema的更改很慢，会带来停机时间。这种代价不是完全值得的：大多数的关系型数据库系统可以在几毫秒之内执行`Alter Table`语句。MySQL是一个需要注意的例外——他在执行`Alter Table`时会复制整个表，这意味着在更改一个大表时需要几分钟甚至几小时的停机时间——尽管有各种工具来解决这种限制。

在大表上运行`UPDATE`语句在任何数据库上有可能很慢，因为每一行都需要重写。如果你觉得那样无法接受，应用程序可以先把`first_name`默认设成`NULL`，在读的时候赋值，就行使用文档数据库一样。

如果因为一些原因（数据是不同构的）导致一个数据集合里的数据没有同样的结构的话，读时schema的方法是有很多优势的——比如，如果：

- 有很对不同类型的对象，把每种类型的对象放在自己的表中是不太现实的
- 数据结构是有外部系统决定的，你无法控制外部系统而且他们可能是随时变化的

在上述情况下，schema可能会本末倒置，无schema的文档可能是个更自然的数据模型。但是在所有数据都有相同结构的情况下，schema对于记录和保证结构是一个有效的机制。我们会在第四章讨论更多的schema和schema演变的细节。

### 查询的数据局部性

一个文档通常是保存成一个连续的字符串，编码成JSON，XML或者是其二进制的变形（比如MongoDB的BSON)。如果你的应用程序经常需要访问整个文档（比如，将其渲染至网页），那么*数据局部性*就带来了性能优势。如果数据是分散在跟多表里，例如图2-1，取数据需要用多个索引查询，这样会导致更多的磁盘查找并花费更多的时间。

只有在你需要文档绝大部分的内同时，局部性的优势才显现出来。即使你只需要很小的一部分，数据库也通常需要加载整个文档，这样对于大文档是非常浪费的。在更新一个文档时，整个文档需要重写——只有不改变文档大小的修改才可以容易地原地执行。因此，通常建议保持相对较小的文档并避免增加文档大小的写入。这些性能限制大大减少了文档模型的使用场景。

需要指出的是，为了局部性聚合相关数据兵不局限于文档模型。比如，谷歌的Spanner数据库能够提供在关系型数据模型里提供相同的数据局部性的属性，他通过以同意不需要schmea声明一个表的行应该是在父表内交错（嵌套的）。Oracle类似地允许使用一个称为 *多表索引集群表（multi-table index cluster tables）* 的类似特性。Bigtable数据模型（用于Cassandra和HBase）中的 *列族（column-family）* 概念与管理局部性的目的类似

在第三章我们会看到能多关于局部性的内容。

### 文档和关系数据库的融合

从21世纪的前十年中期开始，大多数关系数据库系统（不仅是MySQL）就已经支持了XML。这包括了本地修改XML文档的功能，以及在XML文档中进行索引和查询功能，这帮助了应用程序在使用文档数据库时用自己想用的数据模型。

PostgreSQL从9.3版本，MySQL从5.7版本，IBM DB2从10.5版本也有了对JSON文档的相近程度的支持。因为JSON收到了web API的广泛追捧，有可能其他关系数据库也会追随这种脚步来增加对JSON的支持。

在文档型数据库这边，RethinkDB在其查询语言支持关系模型一样的的join，有一些MongoDB驱动程序可以自动解析数据库引用（有效执行客户端join，尽管这看起来数据库中的join执行起来更慢，因为它需要额外的网络往返请求，优化更少）。

看起来关系和文档数据路在过去的一段时间中变得越来越像了，这是个好事：数据模型可以互相补充。如果一个数据库可以解决文档类型的数据，也能执行关系型的查询，应用程序可以中这种最适应他们需要的最好的功能组合。

> Codd最初的对关系模型的描述其实允许在关系型schema中有一些十分类似于的JSON文档的东西。他把那个叫做*非简单域*。这种想法是每一行的值不需要是原始数据类型（比如数字或者字符串），也可以是一个嵌套的关系（表）——所以你可以任意把树结构嵌套成一个值，就像30年后添加到的对JSON或者XML的支持。

一种关系型和文档型的混合模式是未来数据库发展的路线。



## 数据查询语言

当关系模型横空出世时，他同样带来了一种查询数据的新方法：SQL是一种*声明式*的查询语言，但是IMS和CODASYL用*命令式*的查询语言，这啥意思？

很多常用的编程语言都是命令式的。比如，你想拿到一个动物物种的列表，你想在列表里只拿到鲨鱼的话你得这么写：

```
function getSharks() { 
	var sharks = [];
  for (var i = 0; i < animals.length; i++) { 
      if (animals[i].family === "Sharks") {
        sharks.push(animals[i]); 
      }
  }
  return sharks; 
}
```

在关系代数中:

$$ sharks = σ_{family = "sharks"}(animals)

$$ σ（希腊字母西格玛）是选择操作符，只返回符合条件的动物，`family="shark"`。

定义SQL时，它紧密的遵循关系代数的结构：

```sql
SELECT * FROM animals WHERE family = 'Sharks';
```

命令式语言高速计算机在一种顺序下执行一种操作。你可以想象一下逐行遍历代码，判断条件，更新变量，并决定是否再循环一遍。

在声名式的查询语言（比如SQL或者关系代数）中，你主需要明确你查询的数据模式——结果需要满足哪些条件，数据如何转换（比如排序，分组和聚合）——但是你不需要了解是如何去完成这个目标的。我们把这个交给数据库查询优化器来决定用哪种索引和join，并让它决定执行查询中各个部分的顺序。

声名式的查询语言看起来是很迷人的，因为它通常比命令式的API用起来更加简洁和简单。但正重要的是，他同样隐藏了数据库引擎的实现细节，这让我们不用修改查询就能体验到数据库有的性能提升。

比如，在本节开头的命令式代买中，动物的列表看一来是某种顺序。如果数据库在后台想回收未使用的磁盘空间，需要移动数据，这样会更大哦动物出现的顺序。数据库在不中断查询的情况下来如何安全的执行？

这个SQL的例子并不能保证任何顺序，所以如果顺序改变了也并不用在意。但是如果查询使用命令式的代码写的。数据库就永远无法保证代码是否依赖于任何顺序。SQL有限的功能性给了数据库更多做自动优化的空间。

治愈后，声名式语言往往适合并行执行。今天，CPU通过增加更多的核数变得越来越快，而不是靠的比以前更高的时钟运行速度。命令式代码很难分布在多核和多机并行，因为他指定的指令必须按照某种顺序执行。声名式语言在并行执行上可能更快因为他们只指定了结果的模式，而不是确定结果的算法。如果合适的话，数据库可以自由地使用查询语言的并行实现。

### Web上的声名式查询

声名式查询语言的有点并不仅限于数据库。为了展示，让我们在一个完全不同的环境下来比较声名式和命令式语言——一个web浏览器中。

如果你有一个关于海洋东无得网站。用户经常看页面上的鲨鱼，所以你将当先所选的导航项目的中的“鲨鱼”选中，就像：

```html
<ul>
    <li class="selected">1.
        <p>Sharks</p>2.
        <ul>
            <li>Great White Shark</li>
            <li>Tiger Shark</li>
            <li>Hammerhead Shark</li>
        </ul>
    </li>
    <li><p>Whales</p>
        <ul>
            <li>Blue Whale</li>
            <li>Humpback Whale</li>
            <li>Fin Whale</li>
        </ul>
    </li>
</ul>
```

1. 选中的项目用CSS的“selected”样式标记

2. <p>Sharks</p>是当前选中页面的标题

现在你想把当前选中页面的标题改成蓝色背景，这样能做到视觉上的高粱，在CSS里是很简单的：

```css
li.selected > p {
    background-color: blue;
}
```

在这里CSS选择器`li.selected > p`声明了我们想要应用蓝色背景的元素模式：也就是所有`<p>`元素的直接父节点是一个有CSS`selected`样式的元素。例子中的中的`<p>Sharks</p>`就符合这种模式，但是`<p>Whales</p>`不符合，因为他的父节点`<li>`缺少`<class=selected>`样式。

如果用XSL而不是CSS，你做的事也差不多：

```xml
<xsl:template match="li[@class='selected']/p">
    <fo:block background-color="blue">
        <xsl:apply-templates/>
    </fo:block>
</xsl:template>
```

在这里，XPath表达式`li[@class='selected']/p`相当于上例中的CSS选择器`li.selected> p`。CSS和XSL的共同之处在于，它们都是用于指定文档样式的声明式语言。

试想一下如果你用命令式的方法会是什么样。在JavaScript中，使用 文档对象模型（DOM）API，其结果可能如下所示：

```js
var liElements = document.getElementsByTagName("li");
for (var i = 0; i < liElements.length; i++) {
    if (liElements[i].className === "selected") {
        var children = liElements[i].childNodes;
        for (var j = 0; j < children.length; j++) {
            var child = children[j];
            if (child.nodeType === Node.ELEMENT_NODE && child.tagName === "P") {
                child.setAttribute("style", "background-color: blue");
            }
        }
    }
}
```

这段JavaScript代码命令式地将元素设置为蓝色背景，但是代码看起来很糟糕。不仅比CSS和XSL的类似方法更长，更难理解，而且还有一些严重的问题：

- 如果`selected`样式被删除了（比如用户点了另外一个页面），即使代码重新运行，蓝色背景也不会被移除——因此该项目将保持突出显示，直到整个页面被重新加载。使用CSS，浏览器可以自动检测当`<li.selecter > p>`规则不再适用，并在`selected`样式被删除后立即删除蓝色背景。
- 如果你想使用新的API，例如`document.getElementsBy ClassName（“selected”`）甚至`document.evaluate()`）来提高性能——你需要重写代码。另一方面，浏览器商家以在不破坏兼容性的情况下提高CSS和XPath的性能。

在web浏览器中，用声名式的CSS样式比在JavaScript中命令式地操作样式要好的多。类似地，声名式查询语言（比如SQL）看起来比命令式的查询API要好得多。

> IMS和CODASYL都使用命令式API。应用程序通常使用COBOL代码遍历数据库中的记录，一次一条记录

### MapReduce查询

*MapReduce*是一个由谷歌推广出来的编程模型，用来批量处理分布在多台机器上的的大规模数据。一些NoSQL的数据存储（包括MongoDB和CouchDB）可以有限地支持MapReduce的功能，作为在多个文档间只读查询的机制。

MapReduce在第十章有更加详细的描述。从现在开始，我们只会简要讨论一下MongoDB使用的模型。

MapReduce既不是一种声名式的查询语言也不是一个完全命令式的查询API，而是处于两者之间：查询的逻辑用代码片段来表示，这写代码会被处理框架反复调用。代码是基于map（也被称为`collect`）和reduce也被称为（`fold`或者`inject`）函数，两个函数存在于在很多函数式编程语言中。

让我们来给一个例子。想想你是一个海洋生物学家，你可已在每次你在海洋里看到一个动物世界在你的数据库里增加一条观测记录。现在你想生成一个报告来看每个月你能看到多少鲨鱼。

在PostfreSQL中，你可以向这样查询：

```sql
SELECT
    date_trunc('month', observation_timestamp) AS observation_month,1.
    sum(num_animals)                           AS total_animals
FROM observations
WHERE family = 'Sharks'
GROUP BY observation_month;
```

1. `date_trunc('month', timestamp)`函数用于确定包含`timestamp`的日历月份，并返回代表该月份开始的另一个时间戳。换句话说，它将时间戳舍入成最近的月份。

这个查询首先过滤观测记录，得到所有鲨鱼家族的观测记录，然后根据观测的月份来组合观测记录，最后把每个月的观测到的动物的数量加和。

用MongoDB的MapReduce的功能同样也能做到：

```
db.observations.mapReduce(function map() {2.
        var year = this.observationTimestamp.getFullYear();
        var month = this.observationTimestamp.getMonth() + 1;
        emit(year + "-" + month, this.numAnimals);3.
    },
    function reduce(key, values) {4.
        return Array.sum(values);5.
    },
    {
        query: {1.
          family: "Sharks"
        },
        out: "monthlySharkReport"6.
    });
```

1. 过滤器只考虑显式声明的的鲨鱼品种（这是MongoDB针对MapReduce的扩展）。
2. `JavaScript`的`map`函数在每个符合查询的文档手都会被调用一次，`this`设置成文档对象。
3. `map`函数发出一个键（一个用年，月组成的字符串，比如“2013-12”或者“2014-1”）和一个值（观测到的动物数量）
4. `map`输出的键值对按键来分组。对于所有有相同键的键值对（比如相同的月份和年份），`reduce`函数都会被调用一次。
5. `reduce`函数吧某个月观测到的所有动物数量相加。
6. 最终输出写到了`monthlySharkReport`的集合里。

比如，观测记录的集合包括以下两个文档：

```json
{
  observationTimestamp: Date.parse(  "Mon, 25 Dec 1995 12:34:56 GMT"),
  family: "Sharks",
  species: "Carcharodon carcharias",
  numAnimals: 3
{
}
  observationTimestamp: Date.parse("Tue, 12 Dec 1995 16:17:18 GMT"),
  family: "Sharks",
  species:    "Carcharias taurus",
  numAnimals: 4
}
```

`map`函数对于每个文档都会调用一次，结果是emit("1995-12",3)`和`emit("1995-12",4)。接下来以`reduce("1995-12",[3,4])`调用`reduce`函数，将返回`7`。

`map`和`reduce`函数都有一些他们功能上缺陷。他们必须是*纯*函数，那意味着他们只能使用被当做输入传进去的数据。他们不能执行额外的数据库查询，他们也不能有任何副作用。这些限制让数据库在任何地方，以任何顺序运行任何功能，也能在失败是重跑。尽管如此，他们还是非常强大的：他们可以解析字符串，调用库函数，执行计算等等。

MapReduce是一种在相对底层的编程语言，用于计算集群上的分布式执行。更高级的的类似SQL的查询语言可以用MapReduce的pipeline来实现，但是也有很多不用MapReduce的SQL的分布式实现。需要注意的是，SQL并没有限制在必须在单机上运行，MapReduce也没有垄断分布式查询。

对于高级的查询，在查询中能使用JavaScript的代码是一个很重要的功能，但这并不局限于MapReduce——有些SQL数据库也能用JavaScript的函数进行扩展。

使用MapReduce的用法问题是你需要写两个紧密联系的JavaScript函数，这通常比写一个单个查询更困难。不仅如此，声名式的查询语言可以查询优化器来提升性能带来更多机会。针对这些，MongoDB 2.2增加了对声名式查询语言的支持，叫做*聚合管道*。用这种语言写的计数鲨鱼的查询是这样的：

```
db.observations.aggregate([
  { $match: { family: "Sharks" } },
  { $group: {
    _id: {
      year:  { $year:  "$observationTimestamp" },
      month: { $month: "$observationTimestamp" }
    },
    totalAnimals: { $sum: "$numAnimals" } }}
]);
```

聚合管道语言与SQL子集有着类似的表现力，但是它用一种基于JSON的语法，而不是SQL的英语句子式的语法，这种不同可能是喜好的问题。这个故事的寓意是NoSQL系统可能会偶然发现子集重新发明了SQL，尽管带着伪装。





